#!/usr/bin/env python3
# ruff: noqa: PLW1509, S603

from __future__ import annotations

import argparse
import contextlib
import errno
import logging
import os
import re
import shutil
import signal
import subprocess
import sys
import typing as t

LOG: t.Final[logging.Logger] = logging.getLogger(__name__)
BUF_SIZE: t.Final[int] = 16384


def main() -> None:
    options = get_options()

    logging.basicConfig(
        level=logging.DEBUG if options.debug else logging.INFO,
        format=">>> %(message)s",
    )
    LOG.debug("Options %s", options)

    if not options.command:
        sys.exit("No command specified")

    cmd_str = shutil.which(options.command[0])
    if not cmd_str:
        sys.exit(f"Command not found: {options.command[0]}")
    options.command[0] = cmd_str

    sys.exit(run_proc(options) or 0)


def run_proc(options: argparse.Namespace) -> int:
    with subprocess.Popen(options.command, preexec_fn=os.setpgrp) as proc:
        try:
            os.tcsetpgrp(sys.stdin.fileno(), os.getpgid(proc.pid))
        except OSError as exc:
            if exc.errno != errno.ENOTTY:
                raise

        LOG.debug("Wait to the process to clearly complete")
        with contextlib.suppress(subprocess.TimeoutExpired):
            return proc.wait(timeout=options.duration)

        LOG.debug("Timeout. Sent %s", options.grace_signal.name)
        with contextlib.suppress(ProcessLookupError):
            os.kill(proc.pid, options.grace_signal)

        with contextlib.suppress(subprocess.TimeoutExpired):
            return proc.wait(timeout=options.grace_period)

        LOG.debug(
            "Timeout. Send %s to a process leader %d",
            options.grace_signal.name,
            os.getpgid(proc.pid),
        )
        with contextlib.suppress(ProcessLookupError):
            os.killpg(os.getpgid(proc.pid), options.grace_signal)

        with contextlib.suppress(subprocess.TimeoutExpired):
            return proc.wait(timeout=options.grace_period)

        LOG.debug(
            "Timeout. Send SIGKILL to a process leader %d", os.getpgid(proc.pid)
        )
        with contextlib.suppress(ProcessLookupError):
            os.killpg(os.getpgid(proc.pid), signal.SIGKILL)

        return proc.wait()


def get_options() -> argparse.Namespace:
    def type_duration(value: str) -> int:
        matcher = re.fullmatch(
            r"""
            (?:(?P<days>[1-9]\d*)d)?      # days
            (?:(?P<hours>[1-9]\d*)h)?     # hours
            (?:(?P<minutes>[1-9]\d*)m)?   # minutes
            (?:(?P<seconds>[1-9]\d*)s?)?  # seconds
        """,
            value,
            re.VERBOSE | re.IGNORECASE,
        )
        if not matcher:
            raise argparse.ArgumentTypeError(
                f"Invalid duration format: '{value}'"
            )

        data = matcher.groupdict()
        days = int(data.get("days") or 0)
        hours = int(data.get("hours") or 0)
        minutes = int(data.get("minutes") or 0)
        seconds = int(data.get("seconds") or 0)

        return days * 86400 + hours * 3600 + minutes * 60 + seconds

    def type_signal(value: str) -> signal.Signals:
        if value.isdigit():
            return signal.Signals(int(value))

        if not value.startswith("SIG"):
            value = f"SIG{value}"

        return signal.Signals[value]

    parser = argparse.ArgumentParser(
        description="Better timeout with graceful termination",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="Run in debug mode.",
    )
    parser.add_argument(
        "-g",
        "--grace-period",
        type=type_duration,
        default="3s",
        help="Time to wait after sending SIGTERM before sending SIGKILL.",
    )
    parser.add_argument(
        "-s",
        "--grace-signal",
        type=type_signal,
        default="SIGTERM",
        help="Signal to send for graceful termination.",
    )

    parser.add_argument(
        "duration", type=type_duration, help="Time limit in seconds."
    )
    parser.add_argument(
        "command", nargs=argparse.REMAINDER, help="Command to run."
    )

    return parser.parse_args()


if __name__ == "__main__":
    main()
