#!/usr/bin/env python3
# ruff: noqa: T201, S101

from __future__ import annotations

import argparse
import collections
import itertools
import json
import logging
import os
import re
import shlex
import sys
import typing as t

T = t.TypeVar("T")

if t.TYPE_CHECKING:
    JSON = str | float | int | None | list["JSON"] | dict[str, "JSON"]


LOG: t.Final[logging.Logger] = logging.getLogger(__name__)


class IntDict(dict[int, T]):
    def to_list(self) -> list[T]:
        elements: list[T] = []

        for idx in range(len(self)):
            try:
                elements.append(self[idx])
            except IndexError as exc:  # noqa: PERF203
                raise IndexError(f"Index {idx} is missed") from exc

        return elements


class Formatted(collections.UserString):
    pass


if t.TYPE_CHECKING:
    HalfJSON = (
        str | float | int | None | IntDict["HalfJSON"] | dict[str, "HalfJSON"]
    )


def main() -> None:
    options = get_options()

    logging.basicConfig(
        level=logging.DEBUG if options.debug else logging.INFO,
        format=">>> %(message)s",
    )
    LOG.debug("Options %s", options)

    for elem in options.callback(options):
        print(elem if isinstance(elem, Formatted) else shlex.join(elem))


def get_options() -> argparse.Namespace:  # noqa: PLR0915
    parser = argparse.ArgumentParser(
        description="Reshape input data.",
        epilog="It always emits correct shell escaped string by default",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="Enable debug mode.",
    )

    commands = parser.add_subparsers(dest="command", required=True)
    add_input = []

    cmd_repeat = commands.add_parser(
        "repeat",
        aliases=["rp"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Repeat input stream N times",
    )
    cmd_repeat.add_argument(
        "num",
        type=argtype_non_neg_int,
        help="Number of times to repeat the input stream. 0 means forever",
    )
    cmd_repeat.set_defaults(callback=do_repeat)
    add_input.append(cmd_repeat)

    cmd_slice = commands.add_parser(
        "slice",
        aliases=["sl"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Slice input stream",
    )
    cmd_slice.add_argument(
        "start",
        type=argtype_non_neg_int,
        help="Start index (inclusive)",
    )
    cmd_slice.add_argument(
        "end",
        type=argtype_non_neg_int,
        nargs=argparse.OPTIONAL,
        help="End index (inclusive)",
    )
    cmd_slice.add_argument(
        "step",
        type=argtype_non_zero_int,
        nargs=argparse.OPTIONAL,
        default=1,
        help="Step size",
    )
    cmd_slice.set_defaults(callback=do_slice)
    add_input.append(cmd_slice)

    cmd_batch = commands.add_parser(
        "batch",
        aliases=["ba"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Batch input elements into groups of N",
    )
    cmd_batch.add_argument(
        "size",
        type=argtype_non_neg_int,
        help="Batch size. 0 means grouping all elements in a single batch",
    )
    cmd_batch.set_defaults(callback=do_batch)
    add_input.append(cmd_batch)

    cmd_combinations = commands.add_parser(
        "combinations",
        aliases=["co"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Generate combinations of input elements",
    )
    cmd_combinations.add_argument(
        "size",
        type=argtype_positive_int,
        help="Size of each combination",
    )
    cmd_combinations.set_defaults(callback=do_combinations)
    add_input.append(cmd_combinations)

    cmd_rcombinations = commands.add_parser(
        "rcombinations",
        aliases=["rc"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Generate combinations with replacements of input elements",
    )
    cmd_rcombinations.add_argument(
        "size",
        type=argtype_positive_int,
        help="Size of each combination",
    )
    cmd_rcombinations.set_defaults(callback=do_rcombinations)
    add_input.append(cmd_rcombinations)

    cmd_permutations = commands.add_parser(
        "permutations",
        aliases=["pe"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Generate permutations of input elements",
    )
    cmd_permutations.add_argument(
        "size",
        type=argtype_positive_int,
        help="Size of each permutation",
    )
    cmd_permutations.set_defaults(callback=do_permutations)
    add_input.append(cmd_permutations)

    cmd_product = commands.add_parser(
        "product",
        aliases=["pr"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Generate cartesian product of input elements",
    )
    cmd_product.add_argument(
        "input",
        type=argparse.FileType("r"),
        nargs=argparse.ONE_OR_MORE,
        help="Input files. Use '-' for stdin",
    )
    cmd_product.set_defaults(callback=do_product)

    cmd_field = commands.add_parser(
        "field",
        aliases=["fi"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Extract fields from input elements",
    )
    cmd_field.add_argument(
        "-s",
        "--separator",
        type=str,
        default="",
        help=(
            "Separator to use for splitting into fields. "
            "Use shell lexer by default."
        ),
    )
    cmd_field.add_argument(
        "index",
        type=argtype_non_neg_int,
        nargs=argparse.ONE_OR_MORE,
        help="Field indices (1-based)",
    )
    cmd_field.set_defaults(callback=do_field)
    add_input.append(cmd_field)

    cmd_separate = commands.add_parser(
        "separate",
        aliases=["sp"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Separate records using different separator",
    )
    cmd_separate.add_argument(
        "input_separator",
        type=str,
        help="Separator for input line. Empty string means shlex parsing",
    )
    cmd_separate.add_argument(
        "output_separator",
        type=str,
        help="Separator for output line. Empty string means shlex.",
    )
    cmd_separate.set_defaults(callback=do_separate)
    add_input.append(cmd_separate)

    cmd_group = commands.add_parser(
        "group",
        aliases=["gr"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Group elements by first element",
    )
    cmd_group.add_argument(
        "-s",
        "--separator",
        type=str,
        default="",
        help="Separator used to split into elements. Use shell lex by default",
    )
    cmd_group.add_argument(
        "-n",
        "--no-group-key",
        action="store_true",
        default=False,
        help="Do not show group key",
    )
    cmd_group.set_defaults(callback=do_group)
    add_input.append(cmd_group)

    cmd_window = commands.add_parser(
        "window",
        aliases=["wi"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Slide a window over input elements",
    )
    cmd_window.add_argument(
        "-s",
        "--small-windows",
        action="store_true",
        default=False,
        help="Output smaller windows.",
    )
    cmd_window.add_argument(
        "size",
        type=argtype_positive_int,
        help="Window size",
    )
    cmd_window.set_defaults(callback=do_window)
    add_input.append(cmd_window)

    cmd_regexp = commands.add_parser(
        "regex",
        aliases=["re"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Reformat using regexp",
    )
    cmd_regexp.add_argument(
        "template",
        type=argtype_regexp,
        help="Regexp pattern to match",
    )
    cmd_regexp.add_argument(
        "replacement",
        type=str,
        default=r"\g<1>",
        nargs=argparse.OPTIONAL,
        help="Replacement string",
    )
    cmd_regexp.set_defaults(callback=do_regex)
    add_input.append(cmd_regexp)

    cmd_json = commands.add_parser(
        "json",
        aliases=["js"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Process JSON",
    )
    json_commands = cmd_json.add_subparsers(dest="json_command", required=True)

    cmd_json_unpack = json_commands.add_parser(
        "unpack",
        aliases=["u"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Unpack JSON",
    )
    cmd_json_unpack.set_defaults(callback=do_json_unpack)
    add_input.append(cmd_json_unpack)

    cmd_json_pack = json_commands.add_parser(
        "pack",
        aliases=["p"],
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Restore JSON from unpacked format",
    )
    cmd_json_pack.set_defaults(callback=do_json_pack)
    add_input.append(cmd_json_pack)

    for cmd in add_input:
        cmd.add_argument(
            "input",
            type=argparse.FileType("r"),
            default="-",
            nargs=argparse.OPTIONAL,
            help="File to read from. - for stdin.",
        )

    return parser.parse_args()


def do_repeat(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    wrapped_it = ((item,) for item in input_elements(args.input))

    if not args.num:
        yield from itertools.cycle(wrapped_it)
        return

    elements = list(wrapped_it)
    for _ in range(args.num):
        yield from elements


def do_slice(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    start = args.start - 1
    if args.end is None:
        start, end = 0, start
    else:
        end = args.end - 1

    it = itertools.islice(
        ((item,) for item in input_elements(args.input)),
        start,
        end + 1,
        abs(args.step),
    )
    return it if args.step > 0 else reversed(list(it))


def do_batch(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    if args.size == 0:
        if elements := tuple(input_elements(args.input)):
            yield elements
        return

    batch: list[str] = []
    for item in input_elements(args.input):
        batch.append(item)
        if len(batch) == args.size:
            yield batch
            batch.clear()

    if batch:
        yield batch


def do_combinations(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    yield from itertools.combinations(input_elements(args.input), args.size)


def do_rcombinations(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    yield from itertools.combinations_with_replacement(
        input_elements(args.input), args.size
    )


def do_permutations(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    yield from itertools.permutations(input_elements(args.input), args.size)


def do_product(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    iterables = [input_elements(file_) for file_ in args.input]
    yield from itertools.product(*iterables)


def do_template(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    yield from (
        (args.template.format(item),) for item in input_elements(args.input)
    )


def do_regex(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    for item in input_elements(args.input):
        yield (args.template.sub(args.replacement, item),)


def do_field(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    for item in input_elements(args.input):
        if args.separator:
            fields = item.split(args.separator)
        else:
            fields = shlex.split(item)

        yield tuple(
            fields[index - 1]
            for index in args.index
            if 0 < index <= len(fields)
        )


def do_separate(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    for line in input_elements(args.input):
        if args.input_separator:
            fields = line.split(args.input_separator)
        else:
            fields = shlex.split(line)

        if args.output_separator:
            yield Formatted(args.output_separator.join(fields))
        else:
            yield Formatted(shlex.join(line))


def do_group(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    groups: collections.defaultdict[str, list[str]] = collections.defaultdict(
        list
    )

    for item in input_elements(args.input):
        if args.separator:
            fields = item.split(args.separator)
        else:
            fields = shlex.split(item)

        if not fields:
            continue

        key = fields[0]
        groups[key].append(shlex.join(fields[1:]))

    for group_id, data in groups.items():
        if args.no_group_key:
            yield data
        else:
            yield (group_id, *data)


def do_window(
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    window: collections.deque[str] = collections.deque(maxlen=args.size)

    for item in input_elements(args.input):
        window.append(item)
        if args.small_windows or len(window) == args.size:
            yield window

    if not args.small_windows:
        if 0 < len(window) < args.size:
            yield window
        return

    while window:
        yield window
        window.popleft()


def do_json_unpack(  # noqa :C901
    _: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    def unpack(obj: JSON, prefix: str) -> t.Iterator[t.Iterable[str]]:
        match obj:
            case dict():
                for key, value in sorted(obj.items()):
                    assert isinstance(key, str)
                    key = str(key)  # noqa: PLW2901
                    if re.search(r"[^a-zA-Z_]", key):
                        key = json.dumps(key)  # noqa: PLW2901
                    yield from unpack(value, f"{prefix}.{key}")
            case list():
                obj_len = len(str(len(obj)))
                for index, value in enumerate(obj):
                    strindex = str(index).zfill(obj_len)
                    yield from unpack(value, f"{prefix}.{strindex}")
            case str():
                yield (f"{prefix}.=", "str", obj)
            case bool():
                yield (f"{prefix}.=", "bool", "true" if obj else "false")
            case float() | int():
                yield (f"{prefix}.=", "num", str(obj))
            case None:
                yield (f"{prefix}.=", "none", "null")
            case _:
                raise ValueError(f"Unexpected value {obj}")

    yield from unpack(json.load(sys.stdin), "")


def do_json_pack(  # noqa: C901
    args: argparse.Namespace,
) -> t.Iterator[Formatted | t.Iterable[str]]:
    def parse_line(line: str) -> HalfJSON:
        fields = shlex.split(line)
        if len(fields) != 3:  # noqa: PLR2004
            raise ValueError(f"Incorrect line {line}")
        return parse_fields(*fields)

    def parse_fields(path: str, type_: str, value: str) -> HalfJSON:  # noqa: PLR0911
        if m := re.fullmatch(r"\.(\d+)(\..*)", path):
            return IntDict(
                {int(m.group(1)): parse_fields(m.group(2), type_, value)}
            )
        if m := re.fullmatch(r'\."((?:\\.|[^"])+)"(\..*)', path):
            return {
                json.loads(m.group(1)): parse_fields(m.group(2), type_, value)
            }
        if m := re.fullmatch(r"\.([a-zA-Z_]+)(\..*)", path):
            return {m.group(1): parse_fields(m.group(2), type_, value)}

        match (path, type_):
            case ".=", "str":
                return value
            case ".=", "bool":
                return value.lower() == "true"
            case ".=", "none":
                return None
            case ".=", "num":
                try:
                    return int(value)
                except ValueError:
                    return float(value)

        raise ValueError(f"Unexpected line {line}")

    def merge(data: HalfJSON, acc: HalfJSON) -> HalfJSON:
        if (td := type(data)) is not (ta := type(acc)):
            raise TypeError(f"Type mismatch {td} != {ta}")
        if isinstance(data, dict):
            assert isinstance(acc, dict)
            for k, v in data.items():
                if k not in acc:
                    acc[k] = v  # type: ignore[index]
                else:
                    merge(v, acc[k])  # type: ignore[index]
            return acc
        return data

    def final_merge(root: HalfJSON) -> JSON:
        if not isinstance(root, dict):
            return root
        for k, v in root.items():
            root[k] = final_merge(v)  # type: ignore[index, assignment]
        if isinstance(root, IntDict):
            return t.cast("list[JSON]", root.to_list())
        return t.cast("JSON", root)

    results: HalfJSON = {}
    for line in input_elements(args.input):
        results = merge(parse_line(f".root{line}"), results)

    yield Formatted(
        json.dumps(
            final_merge(results["root"]),  # type: ignore[index]
            check_circular=False,
            indent=2,
            sort_keys=True,
        )
    )


def input_elements(base: t.Iterable[str]) -> t.Iterator[str]:
    for line in base:
        yield line.rstrip(os.linesep)


def argtype_non_neg_int(value: str) -> int:
    try:
        ivalue = int(value)
    except ValueError as exc:
        raise argparse.ArgumentTypeError(f"{value} is not an integer") from exc

    if ivalue < 0:
        raise argparse.ArgumentTypeError(f"{value} is not a positive integer")

    return ivalue


def argtype_non_zero_int(value: str) -> int:
    try:
        ivalue = int(value)
    except ValueError as exc:
        raise argparse.ArgumentTypeError(f"{value} is not an integer") from exc

    if ivalue == 0:
        raise argparse.ArgumentTypeError(f"{value} is not a non-zero integer")

    return ivalue


def argtype_positive_int(value: str) -> int:
    try:
        ivalue = int(value)
    except ValueError as exc:
        raise argparse.ArgumentTypeError(f"{value} is not an integer") from exc

    if ivalue <= 0:
        raise argparse.ArgumentTypeError(f"{value} is not a positive integer")

    return ivalue


def argtype_template_str(value: str) -> str:
    try:
        value.format("")
    except Exception as exc:
        raise argparse.ArgumentTypeError(
            f"{value} is not a valid template string"
        ) from exc

    return value


def argtype_regexp(value: str) -> re.Pattern[str]:
    try:
        return re.compile(value, re.UNICODE)
    except re.error as exc:
        raise argparse.ArgumentTypeError(
            f"{value} is not a valid regexp"
        ) from exc

    return value


if __name__ == "__main__":
    main()
