#!/usr/bin/env python3
# ruff: noqa: S603, PLW1509

from __future__ import annotations

import argparse
import contextlib
import errno
import gzip
import hashlib
import logging
import os
import pathlib
import select
import shlex
import shutil
import subprocess
import sys
import typing as t

LOG: t.Final[logging.Logger] = logging.getLogger(__name__)

PATH_STATE_HOME: t.Final[pathlib.Path] = pathlib.Path(
    os.getenv(
        "XDG_STATE_HOME", pathlib.Path.home() / ".local" / "state" / "9seconds"
    ),
)
PATH_STATE: t.Final[pathlib.Path] = PATH_STATE_HOME / "_cache"

BUF_SIZE: t.Final[int] = 4096

RECORD_TYPE_STDOUT: t.Final[bytes] = b"\x01"
RECORD_TYPE_STDERR: t.Final[bytes] = b"\x02"
RECORD_TYPE_SIZE: t.Final[bytes] = b"\x03"


def main() -> None:
    options = get_options()
    PATH_STATE.mkdir(parents=True, exist_ok=True)

    logging.basicConfig(
        level=logging.DEBUG if options.debug else logging.INFO,
        format=">>> %(message)s",
    )
    LOG.debug("Options: %s", options)

    if not options.command:
        sys.exit("No command specified")

    cmd_str = shutil.which(options.command[0])
    if not cmd_str:
        sys.exit(f"Command not found: {options.command[0]}")
    options.command[0] = cmd_str

    digest = hashlib.sha256(usedforsecurity=False)
    for chunk in options.command:
        digest.update(chunk.encode("utf-8"))
        digest.update(b"\0")

    cache_filepath = PATH_STATE / digest.hexdigest()
    if options.ignore_cache or not cache_filepath.exists():
        run_command(options.command, cache_filepath)

    sys.exit(read_cache(cache_filepath))


def run_command(cmd: list[str], cache_filepath: pathlib.Path) -> None:
    LOG.debug("Running command: %s", shlex.join(cmd))

    with contextlib.ExitStack() as stack:
        stdout_r, stdout_w = os.pipe()
        stderr_r, stderr_w = os.pipe()

        cache_raw_fp = stack.enter_context(cache_filepath.open("wb"))
        cache_fp = gzip.GzipFile(fileobj=cache_raw_fp, mode="wb")
        stack.callback(cache_fp.close)

        proc = stack.enter_context(
            subprocess.Popen(
                cmd,
                stdout=stdout_w,
                stderr=stderr_w,
                preexec_fn=os.setpgrp,
            )
        )

        os.close(stdout_w)
        os.close(stderr_w)

        try:
            os.tcsetpgrp(sys.stdin.fileno(), os.getpgid(proc.pid))
        except OSError as exc:
            if exc.errno != errno.ENOTTY:
                raise

        reading = True
        while reading:
            reading = proc.poll() is None

            rlist, wlist, _ = select.select(
                [stdout_r, stderr_r],
                [cache_fp],
                [],
                0.01,
            )
            if not (wlist and rlist):
                continue

            for fileno in rlist:
                data = os.read(fileno, BUF_SIZE)
                cache_fp.write(
                    RECORD_TYPE_STDOUT
                    if fileno == stdout_r
                    else RECORD_TYPE_STDERR
                )
                cache_fp.write(len(data).to_bytes(2, "little"))
                cache_fp.write(data)

        LOG.debug("Process exited with code: %d", proc.returncode)

        cache_fp.write(RECORD_TYPE_SIZE)
        cache_fp.write(proc.returncode.to_bytes(2, "little", signed=True))


def read_cache(cache_filepath: pathlib.Path) -> int:
    LOG.debug("Reading cache from: %s", str(cache_filepath))

    with contextlib.ExitStack() as stack:
        cache_fp = stack.enter_context(gzip.open(cache_filepath, "rb"))

        while record_type := cache_fp.read(1):
            if record_type == RECORD_TYPE_SIZE:
                return int.from_bytes(
                    cache_fp.read(2), signed=True, byteorder="little"
                )

            obj = sys.stdout
            if record_type == RECORD_TYPE_STDERR:
                obj = sys.stderr

            size = int.from_bytes(cache_fp.read(2), "little")
            os.write(obj.fileno(), cache_fp.read(size))

    return 0


def get_options() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Cache result of a function execution",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="Run in debug mode",
    )
    parser.add_argument(
        "-n",
        "--ignore-cache",
        action="store_true",
        default=False,
        help="Ignore the cache and force re-execution",
    )

    parser.add_argument(
        "command",
        nargs=argparse.REMAINDER,
        help="The command to execute",
    )

    return parser.parse_args()


if __name__ == "__main__":
    main()
