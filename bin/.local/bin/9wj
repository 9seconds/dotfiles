#!/usr/bin/env python3

from __future__ import annotations

import argparse
import http
import json
import logging
import random
import sys
import time
import typing as t
import urllib.parse
import urllib.request

LOG: t.Final[logging.Logger] = logging.getLogger(__name__)


def main() -> int | None:
    options = get_options()

    logging.basicConfig(
        level=logging.DEBUG if options.debug else logging.ERROR,
        format=">>> %(message)s",
    )

    url = options.job_url
    if not url.endswith("/api/json"):
        url = f"{url.rstrip('/')}/api/json"

    request = urllib.request.Request(  # noqa: S310
        url,
        headers={
            "Accept": "application/json",
            "User-Agent": "9wj/1.0",
        },
    )

    sleeper = sleep_time(options.base_sleep, options.sleep_cap)

    while True:
        with urllib.request.urlopen(request, timeout=5) as resp:  # noqa: S310
            if resp.status != http.HTTPStatus.OK:
                LOG.error("Failed to fetch job status: %s", resp.status)
                return 1

            match json.load(resp):
                case {"inProgress": True}:
                    LOG.info("Job is still in progress...")
                    time.sleep(next(sleeper))
                case {"result": "SUCCESS"}:
                    LOG.info("Job completed successfully.")
                    return 0
                case {"result": result}:
                    LOG.error("Job failed with result: %s", result)
                    return 1


def get_options() -> argparse.Namespace:
    def type_url(value: str) -> str:
        parsed = urllib.parse.urlparse(value)
        if not parsed.scheme or not parsed.netloc:
            raise argparse.ArgumentTypeError(f"Invalid URL: {value}")
        if parsed.scheme not in ("http", "https"):
            raise argparse.ArgumentTypeError(
                f"Unsupported URL scheme: {parsed.scheme}",
            )
        return value

    def type_sleep(value: str) -> float:
        try:
            sleep = float(value)
        except ValueError as exc:
            raise argparse.ArgumentTypeError(
                f"Invalid sleep cap value: {value}",
            ) from exc
        if sleep <= 0:
            raise argparse.ArgumentTypeError(
                f"Sleep cap must be positive: {value}",
            )
        return sleep

    parser = argparse.ArgumentParser(
        description="Wait for Jenkins job to be completed",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="Run in debug mode",
    )
    parser.add_argument(
        "-c",
        "--sleep-cap",
        type=type_sleep,
        default=60.0,
        help="Maximum sleep time between status checks (in seconds)",
    )
    parser.add_argument(
        "-b",
        "--base-sleep",
        type=type_sleep,
        default=1.0,
        help="Base sleep time between status checks (in seconds)",
    )

    parser.add_argument(
        "job_url",
        type=type_url,
        help="The Jenkins job URL to wait for",
    )

    return parser.parse_args()


def sleep_time(base: float, cap: float) -> t.Iterator[float]:
    # https://aws.amazon.com/ru/blogs/architecture/exponential-backoff-and-jitter/
    sleep = base
    while True:
        sleep = min(cap, random.uniform(base, sleep * 3))  # noqa: S311
        yield sleep


if __name__ == "__main__":
    sys.exit(main())
