#!/usr/bin/env python3
# ruff: noqa: PLW1509, S603

from __future__ import annotations

import argparse
import contextlib
import errno
import logging
import os
import re
import select
import shutil
import signal
import subprocess
import sys
import threading
import typing as t

LOG: t.Final[logging.Logger] = logging.getLogger(__name__)
BUF_SIZE: t.Final[int] = 16384


def main() -> None:
    options = get_options()

    logging.basicConfig(
        level=logging.DEBUG if options.debug else logging.INFO,
        format=">>> %(message)s",
    )
    LOG.debug("Options %s", options)

    if not options.command:
        sys.exit("No command specified")

    cmd_str = shutil.which(options.command[0])
    if not cmd_str:
        sys.exit(f"Command not found: {options.command[0]}")
    options.command[0] = cmd_str

    sys.exit(run_proc(options) or 0)


def run_proc(options: argparse.Namespace) -> int:
    with contextlib.ExitStack() as stack:
        master_fd, slave_fd = os.openpty()
        stack.callback(os.close, master_fd)
        stack.callback(os.close, slave_fd)

        proc = stack.enter_context(
            subprocess.Popen(
                options.command,
                stdin=slave_fd,
                preexec_fn=os.setpgrp,
            )
        )
        if os.isatty(sys.stdin.fileno()):
            try:
                os.tcsetpgrp(sys.stdin.fileno(), os.getpgid(proc.pid))
            except OSError as exc:
                if exc.errno != errno.ENOTTY:
                    raise

        evt = threading.Event()

        th = threading.Thread(
            target=proc_monitor,
            args=(proc, options, evt),
            daemon=True,
        )
        th.start()

        while not evt.wait(0.05):
            rd, wr, _ = select.select([sys.stdin], [master_fd], [], 0.05)
            if rd and wr:
                os.write(master_fd, os.read(sys.stdin.fileno(), BUF_SIZE))

        th.join()

        return proc.returncode


def proc_monitor(  # noqa: C901
    proc: subprocess.Popen[t.AnyStr],
    options: argparse.Namespace,
    evt: threading.Event,
) -> None:
    LOG.debug("Wait to the process to clearly complete")
    try:
        proc.wait(timeout=options.duration)
    except subprocess.TimeoutExpired:
        pass
    else:
        return evt.set()

    LOG.debug("Timeout. Sent %s", options.grace_signal.name)
    try:
        os.kill(proc.pid, options.grace_signal)
    except ProcessLookupError:
        LOG.debug("Process already terminated.")
    else:
        return evt.set()

    try:
        proc.wait(timeout=options.grace_period)
    except subprocess.TimeoutExpired:
        pass
    else:
        return evt.set()

    LOG.debug(
        "Timeout. Send %s to a process leader %d",
        options.grace_signal.name,
        os.getpgid(proc.pid)
    )
    try:
        os.killpg(os.getpgid(proc.pid), options.grace_signal)
    except ProcessLookupError:
        LOG.debug("Process already terminated.")

    try:
        proc.wait(timeout=options.grace_period)
    except subprocess.TimeoutExpired:
        pass
    else:
        return evt.set()

    LOG.debug(
        "Timeout. Send SIGKILL to a process leader %d",
        os.getpgid(proc.pid)
    )
    try:
        os.killpg(os.getpgid(proc.pid), signal.SIGKILL)
    except ProcessLookupError:
        LOG.debug("Process already terminated.")

    try:
        proc.wait()
    except Exception as exc:
        LOG.debug("Exception during final wait: %s", exc)
        raise

    return evt.set()


def get_options() -> argparse.Namespace:
    def type_duration(value: str) -> int:
        matcher = re.fullmatch(
            r"""
            (?:(?P<days>[1-9]\d*)d)?      # days
            (?:(?P<hours>[1-9]\d*)h)?     # hours
            (?:(?P<minutes>[1-9]\d*)m)?   # minutes
            (?:(?P<seconds>[1-9]\d*)s?)?  # seconds
        """,
            value,
            re.VERBOSE | re.IGNORECASE,
        )
        if not matcher:
            raise argparse.ArgumentTypeError(
                f"Invalid duration format: '{value}'"
            )

        data = matcher.groupdict()
        days = int(data.get("days") or 0)
        hours = int(data.get("hours") or 0)
        minutes = int(data.get("minutes") or 0)
        seconds = int(data.get("seconds") or 0)

        return days * 86400 + hours * 3600 + minutes * 60 + seconds

    def type_signal(value: str) -> signal.Signals:
        if value.isdigit():
            return signal.Signals(int(value))

        if not value.startswith("SIG"):
            value = f"SIG{value}"

        return signal.Signals[value]

    parser = argparse.ArgumentParser(
        description="Better timeout with graceful termination",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="Run in debug mode.",
    )
    parser.add_argument(
        "-g",
        "--grace-period",
        type=type_duration,
        default="3s",
        help="Time to wait after sending SIGTERM before sending SIGKILL.",
    )
    parser.add_argument(
        "-s",
        "--grace-signal",
        type=type_signal,
        default="SIGTERM",
        help="Signal to send for graceful termination.",
    )

    parser.add_argument(
        "duration", type=type_duration, help="Time limit in seconds."
    )
    parser.add_argument(
        "command", nargs=argparse.REMAINDER, help="Command to run."
    )

    return parser.parse_args()


if __name__ == "__main__":
    main()
