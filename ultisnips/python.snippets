priority 10


global !p

sentinel = object()

def or_empty(value, print_value=sentinel, strip=False):
	if not value:
		return ""

	to_print = print_value
	if to_print is sentinel:
		to_print = value

	return to_print.strip() if strip else to_print

def short_quote(value):
	return or_empty(value, '"""')

def long_quote(value, ending=""):
	return or_empty(value, '"""\n' + ending)

def multiline_delimeter(text, delimeter="-", prefix=""):
	max_length = 0

	for line in text.splitlines():
		line = line.lstrip()
		if prefix and line.startswith(prefix):
			line = line[len(prefix):]
		max_length = max(max_length, len(line.strip()))

	return delimeter * max_length

def comment_out(text):
	lines = [""] + text.splitlines()

	if len(lines) > 1:
		for line in lines:
			snip.rv += "\n" + snip.mkline("# " + line.strip())

endglobal

snippet # "Comment" i
  # $1
endsnippet

snippet #T "TODO comment" b
# TODO(${1:`git config user.name || whoami`})`!p snip.rv = or_empty(t[2], ": ")`$2`!p comment_out(snip.v.text)`
endsnippet


snippet #F "FIXME comment" b
# FIXME(${1:`git config user.name || whoami`})`!p snip.rv = or_empty(t[2], ": ")`$2`!p comment_out(snip.v.text)`
endsnippet


snippet #H "HACK comment" b
# HACK(${1:`git config user.name || whoami`})`!p snip.rv = or_empty(t[2], ": ")`$2`!p comment_out(snip.v.text)`
endsnippet


snippet #X "XXX comment" b
# XXX(${1:`git config user.name || whoami`})`!p snip.rv = or_empty(t[2], ": ")`$2`!p comment_out(snip.v.text)`
endsnippet


snippet #D "Temporary disable the block of code" b
# FIXME(${1:`git config user.name || whoami`}): TEMPORARY DISABLED
#
# ${2:Reason}`!p
comment_out(snip.v.text)`
#
# FIXME($1): END OF TEMPORARY DISABLED BLOCK
endsnippet


snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
# -*- coding: utf-8 -*-


$0
endsnippet


snippet #!3 "Shebang header for python 3 scripts" b
#!/usr/bin/env python3
# -*- coding: utf-8 -*-


$0
endsnippet


snippet pdb "Put PDB tracing here" b
from pdb import set_trace; set_trace()
endsnippet


snippet ipdb "Put iPDB tracing here" b
from ipdb import set_trace; set_trace()
endsnippet


snippet __script "Start script" b
#!/usr/bin/env python
# -*- coding: utf-8 -*-
`!p snip.rv = short_quote(t[1])`${1:Script description}`!p snip.rv = short_quote(t[1])`


import os
import sys


def main():
	${2:${VISUAL}}

	return os.EX_OK


if __name__ == "__main__":
	sys.exit(main())
endsnippet


snippet __module "Start module" b
# -*- coding: utf-8 -*-


$0
endsnippet


snippet imp "Import module by name" b
import ${1:module}
endsnippet


snippet frimp "'from module import name' clause" b
from ${1:.} import ${2:*}
endsnippet


snippet tryex "'try/except' clause" b
try:
	${1:${VISUAL}}
except ${2:Exception}`!p snip.rv = or_empty(t[3], " as ")`${3:exc}:
	${4:pass}
endsnippet


snippet tryfi "'try/finally' clause'" b
try:
	${1:${VISUAL}}
finally:
	$2
endsnippet


snippet tryexfi "'try/except/finally' clause" b
try:
	${1:${VISUAL}}
except ${2:Exception}`!p snip.rv = or_empty(t[3], " as ")`${3:exc}:
	${4:pass}
finally:
	$5
endsnippet


snippet def "Function definition" b
def ${1:function}(${2:*args, **kwargs}):
	${3:${VISUAL:pass}}
endsnippet


snippet defm "Method definition" b
def ${1:method}(self`!p snip.rv = or_empty(t[2], ", ")`${2:*args, **kwargs}):
	${3:${VISUAL:pass}}
endsnippet


snippet defc "Class method definition" b
@classmethod
def ${1:method}(cls`!p snip.rv = or_empty(t[2], ", ")`${2:*args, **kwargs}):
	${3:${VISUAL:pass}}
endsnippet


snippet defs "Class method definition" b
@staticmethod
def ${1:method}(${2:*args, **kwargs}):
	${3:${VISUAL:pass}}
endsnippet


snippet deft "Test method definition" b
def test_${1:ok}(self):
	${2:${VISUAL:pass}}
endsnippet


snippet defg "Magic method" b
def __$1__(self`!p snip.rv = or_empty(t[2], ", ")`${2:*args, **kwargs}):
	${3:${VISUAL:pass}}
endsnippet


snippet for "For loop" b:
for ${1:item} in ${2:$1s}:
	${3:${VISUAL:pass}}
endsnippet


snippet while "While loop" b:
while ${1:True}:
	${2:${VISUAL:pass}}
endsnippet


snippet if "If statement" b:
if ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet


snippet ife "If statement" b:
if ${1:condition}:
	${2:${VISUAL:pass}}
else:
	${3:pass}
endsnippet


snippet lamb "Lambda" is
lambda ${1:x}: ${2:$1}
endsnippet


snippet with "with statement" b
with ${1:expr}`!p snip.rv = or_empty(t[2], " as ")`${2:var}:
	${3:${VISUAL:pass}}
${0}
endsnippet


snippet [] "List comprehension" is
[${1:${4:$2} for ${2:item} in ${3:$2s}}]
endsnippet


snippet {} "Dict comprehension" is
{${1:${5:$2}: ${6:$3} for ${2:k}, ${3:v} in ${4:iterable}}}
endsnippet


snippet {}d "Dict comprehension old-style" is
dict((${4:$1}, ${5:$2}) for ${1:k}, ${2:v} in ${3:iterable})
endsnippet


snippet deco "Simple decorator" b
def ${1:decorated}(${2:func}):
	@${3:functools.wraps}($2)
	def decorator(${4:*args, **kwargs}):
		${5:return $2($4)}

	return decorator
endsnippet


snippet decoco "Double nested decorator" b
def ${1:decorated}(${2:*gargs, **gkwargs}):
	def inner_decorator(${3:func}):
		@${4:functools.wraps}($3):
		def outer_decorator(${5:*args, **kwargs}):
			${6:return $3($5)}

		return outer_decorator
	return inner_decorator
endsnippet


snippet propr "Read property" b
@property
def ${1:name}(self):
	${2:${VISUAL}}
endsnippet


snippet propw "Read/write property" b
@property
def ${1:name}(self):
	${2:${VISUAL}}

@$1.setter
def $1_setter(self, value):
	${3}
endsnippet


snippet class "Generic class" b
class ${1:ClassName}(${2:object}):
	${3:pass}
endsnippet


snippet classi "Generic class with constructor" b
class ${1:ClassName}(${2:object}):

	def __init__(self`!p snip.rv = or_empty(t[3], ", ")`${3}):
		super($1, self).__init__($3)
		`!p
snip >> 2
value = None

for value in t[3].split(","):
	if value:
		snip += "self.{0} = {0}".format(value.strip())

if value:
	snip += ""`
		${4}
endsnippet

snippet classistr "Generic class with str" b
class ${1:ClassName}(${2:object}):

	def __init__(self`!p snip.rv = or_empty(t[3], ", ")`${3}):
		super($1, self).__init__($3)
		`!p
snip >> 2
value = None

for value in t[3].split(","):
	if value:
		snip += "self.{0} = {0}".format(value.strip())

if value:
	snip += ""`
		${4}

	def __repr__(self):
		return `!p
params, args, idx = [], [], 0

for value in t[3].split(","):
	if not value:
		continue

	value = value.strip()

	params.append("{0}={{{1}}}".format(value, idx))
	args.append("self.{0}".format(value))

	idx += 1

params = ", ".join(params)
args = ", ".join(args)

snip.rv = '"<{0}({1})>".format({2})'.format(t[1], params, args)`

	def __str__(self):
		return "<$1>"

	def __unicode__(self):
		return str(self).encode("utf-8")
endsnippet


snippet sae. "self.assertEqual" b
self.assertEqual(${1:one}, ${2:another})

endsnippet


snippet sane. "self.assertNotEqual" b
self.assertNotEqual(${1:one}, ${2:another})

endsnippet


snippet sat. "self.assertTrue" b
self.assertTrue(${1:expression})

endsnippet


snippet saf. "self.assertFalse" b
self.assertFalse(${1:expression})

endsnippet


snippet sai. "self.assertIs" b
self.assertIs(${1:one}, ${2:another})

endsnippet


snippet sai_. "self.assertIn" b
self.assertIn(${1:object}, ${2:$1s})

endsnippet


snippet sain. "self.assertIsNot" b
self.assertIsNot(${1:one}, ${2:another})

endsnippet


snippet sani. "self.assertNotIn" b
self.assertNotIn(${1:object}, ${2:$1s})

endsnippet


snippet saine. "self.assertIsNone" b
self.assertIsNone(${1:expression})

endsnippet


snippet sainne. "self.assertIsNotNone" b
self.assertIsNotNone(${1:expression})

endsnippet


snippet saii. "self.assertIsInstance" b
self.assertIsInstance(${1:object}, ${2:class})

endsnippet


snippet sanii. "self.assertNotIsInstance" b
self.assertNotIsInstance(${1:object}, ${2:class})

endsnippet


snippet sars. "self.assertRaises" b
self.assertRaises(${1:Exception}, ${2:function}`!p snip.rv = or_empty(t[3], ", ")`$3)

endsnippet
