#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>
"""
This scripts allows execution of command in each dir for each file it met.

eachdir -- gzip -9 %FILENAME%

it will compress all files.
"""


from __future__ import unicode_literals, print_function

import argparse
import collections
import fnmatch
import itertools
import logging
import multiprocessing
import operator
import os
import os.path
import subprocess
import sys


if sys.version_info.major == 2:
    ifilter = itertools.ifilter
    ifilterfalse = itertools.ifilterfalse
else:
    ifilter = filter
    ifilterfalse = itertools.filterfalse


class Traverser(collections.Iterable):

    def __init__(self, root_dir, current_dir, current_depth, depth,
                 directory_matcher, filename_matcher, directories_only):
        self.max_depth = depth
        self.current_depth = current_depth
        self.directory_matcher = directory_matcher
        self.filename_matcher = filename_matcher
        self.dir_only = directories_only
        self.root_dir = os.path.abspath(root_dir)
        self.current_dir = os.path.abspath(current_dir)

    def walk(self):
        if self.current_depth > self.max_depth:
            logging.debug(
                "[Traverser] current depth %d exceed max depth %s, "
                "stop walking here.", self.current_depth, self.max_depth)
            raise StopIteration

        for entry in os.listdir(self.current_dir):
            absentry = os.path.join(self.current_dir, entry)
            isdir = os.path.isdir(absentry)

            logging.debug("[Traverser] Process entry %r (abs=%r, isdir=%s)",
                          entry, absentry, isdir)
            path = Path(absentry, isdir, self.root_dir)
            logging.debug("[Traverser] Path %r processed to %s", entry, path)

            yield path

            if isdir:
                traverser = Traverser(
                    self.root_dir,
                    absentry,
                    self.current_depth + 1,
                    self.max_depth,
                    self.directory_matcher,
                    self.filename_matcher,
                    self.dir_only)

                for entry in traverser:
                    yield entry

    def traverse(self):
        items = self.walk()

        items = ifilter(
            lambda it: fnmatch.fnmatch(it.filename, self.filename_matcher),
            items)
        items = ifilter(
            lambda it: fnmatch.fnmatch(it.rdirname, self.directory_matcher),
            items)

        if self.dir_only:
            items = ifilter(operator.attrgetter("isdir"), items)
        else:
            items = ifilterfalse(operator.attrgetter("isdir"), items)

        return items

    __iter__ = traverse


class Path(object):

    def __init__(self, abspath, isdir, root_path):
        self.absfilename = abspath
        self.isdir = isdir
        self.root_path = root_path

    @property
    def absdirname(self):
        return os.path.dirname(self.absfilename)

    @property
    def dirname(self):
        return os.path.basename(self.absdirname)

    @property
    def rdirname(self):
        return os.path.relpath(self.absdirname, self.root_path)

    @property
    def rfilename(self):
        return os.path.relpath(self.absfilename, self.root_path)

    @property
    def filename(self):
        return os.path.basename(self.absfilename)

    def prepare(self, command):
        prepared = []

        for chunk in command:
            pchunk = chunk.replace("%DIRNAME%", self.dirname)
            pchunk = pchunk.replace("%RDIRNAME%", self.rdirname)
            pchunk = pchunk.replace("%ABSDIRNAME%", self.absdirname)
            pchunk = pchunk.replace("%FILENAME%", self.filename)
            pchunk = pchunk.replace("%RFILENAME%", self.rfilename)
            pchunk = pchunk.replace("%ABSFILENAME%", self.absfilename)

            logging.debug("[Path %s] Chunk %r processed to %r",
                          self, chunk, pchunk)

            prepared.append(pchunk)

        return prepared

    def __str__(self):
        return "<Path(absfilename={0}, isdir={1}, root_path={2})>".format(
            self.absfilename, self.isdir, self.root_path)


def execute(command, dry_run, shell, path):
    prepared_command = path.prepare(command)
    os.chdir(path.absdirname)

    logging.info("Execute %s on %s (cwd=%r)",
                 prepared_command, path, os.getcwd())

    if dry_run:
        command_to_execute = subprocess.list2cmdline(prepared_command)
        print(command_to_execute)
        return

    if shell:
        prepared_command = subprocess.list2cmdline(prepared_command)

    try:
        subprocess.check_call(prepared_command, shell=shell)
    except Exception as exc:
        logging.error("Command %s failed: %s", prepared_command, exc)
        if isinstance(exc, subprocess.CalledProcessError):
            return exc.returncode
        return os.EX_SOFTWARE
    else:
        return os.EX_OK


def main():
    options = get_options()
    setup_logging(options.debug)
    logging.info("Options: %s", options)

    workers = options.parallel
    if not workers:
        workers = multiprocessing.cpu_count()
    pool = multiprocessing.Pool(workers)

    traverser = Traverser(
        root_dir=options.root_dir,
        current_dir=options.root_dir,
        current_depth=0,
        depth=options.depth,
        directory_matcher=options.directory_match,
        filename_matcher=options.filename_match,
        directories_only=options.directories_only)

    results = []
    for item in traverser:
        result = pool.apply_async(execute, (options.command, options.dry_run,
                                            options.shell, item))
        results.append(result)

    pool.close()
    pool.join()

    return max(result.get() for result in results)


def setup_logging(debug):
    logging.basicConfig(
        level=logging.DEBUG if debug else logging.ERROR,
        format="%(levelname)5s:%(lineno)3d: %(message)s")


def get_options():
    parser = argparse.ArgumentParser(
        description=(
            "%(prog)s traverse directories and execute command against "
            "each suitable filename."),
        epilog=(
            "There are several variables defined for command: "
            "%DIRNAME% - the name of the current directory, "
            "%RDIRNAME% - relative path to the root directory, "
            "%ABSDIRNAME% - absolute path for the current directory, "
            "%FILENAME% - the name of the file, "
            "%RFILENAME% - the path to the file, relative to the root, "
            "%ABSFILENAME% - the absolute file path"))

    parser.add_argument(
        "-d", "--debug",
        help="Run in debug mode.",
        action="store_true",
        default=False)
    parser.add_argument(
        "-n", "--dry-run",
        help="Do not actually execute command.",
        action="store_true",
        default=False)
    parser.add_argument(
        "-l", "--depth",
        help="How deep are we dive into directories. By default is no limit.",
        type=int,
        default=float("inf"))
    parser.add_argument(
        "-i", "--directory-match",
        help=(
            "Process only directories which match following regexp. "
            "By default all directories are matched."),
        default="*")
    parser.add_argument(
        "-f", "--filename-match",
        help=(
            "Process only filenames which match following regexp. "
            "By default all files are matched."),
        default="*")
    parser.add_argument(
        "-o", "--directories-only",
        help="Process directories, not filenames. By default is False",
        action="store_true",
        default=False)
    parser.add_argument(
        "-s", "--shell",
        help="Run command in shell. By default is False",
        action="store_true",
        default=False)
    parser.add_argument(
        "-p", "--parallel",
        help=(
            "How many parallel processes we need to use. By default 1. "
            "0 means number of cores"),
        type=int,
        default=1)
    parser.add_argument(
        "-r", "--root-dir",
        help=(
            "Consider this directory as root. By default current "
            "working directory is used."),
        default=os.getcwd())

    parser.add_argument(
        "command",
        help="Command to execute",
        nargs=argparse.ONE_OR_MORE)

    return parser.parse_args()


if __name__ == "__main__":
    sys.exit(main())
