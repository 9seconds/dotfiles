#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>
"""
This scripts reads a content of 'git log' (you may set your own options)
and dumps this list into another format.

3 formats are available out of box:
    1. JSON
    2. SQLite database
    3. XML file

XML here just because why not. JSON is for jq usage. Main format, actually,
is SQLite database.
"""


from __future__ import absolute_import, print_function, unicode_literals

import argparse
import codecs
import datetime
import functools
import io
import itertools
import json
import logging
import os
import platform
import sqlite3
import subprocess
import sys
import xml.etree.ElementTree as etree


# PyPy has Python-only optimizations and sad state of C-extension API.
# So all those import-ladders only for reference implementation.
if platform.python_implementation() == "CPython":
    try:
        import ujson as json
    except ImportError:
        try:
            import simplejson as json
        except ImportError:
            pass

    try:
        import xml.etree.cElementTree as etree
    except ImportError:
        pass


# Little SIX replacement
if sys.version_info.major == 2:
    ifilter = itertools.ifilter
    izip = itertools.izip
    to_str = unicode
else:
    ifilter = filter
    izip = zip
    to_str = str


COMMIT_START = "\x01"
"""Symbol of commit start (this need to differ commit/numstat splits)."""

COMMIT_START_FORMAT = "%x01"
"""How does COMMIT_START looks like for git format string."""

COMMIT_FINISH = "\x00"
"""Symbol of commit finish (this need to differ commit/numstat splits)."""

COMMIT_FINISH_FORMAT = "%x00"
"""How does COMMIT_START looks like for git format string."""

COMMIT_FORMAT = "%n".join(
    [
        COMMIT_START_FORMAT,
        "%H",  #   0 | full commit hash
        "%h",  #   1 | 1abbrev commit hash
        "%P",  #   2 | full parent hashes, space separated
        "%p",  #   3 | abbrev parent hashes, space separated
        "%an",  #  4 | commit author name
        "%aN",  #  5 | mailmap author name
        "%ae",  #  6 | commit author email
        "%aE",  #  7 | mailmap author email
        "%at",  #  8 | author date in timestamp
        "%cn",  #  9 | commit committer name
        "%cN",  # 10 | mailmap comitter name
        "%ce",  # 11 | commit comitter email
        "%cE",  # 12 | mailmap comitter email
        "%ct",  # 13 | comitter date in timestamp
        "%D",  #  14 | ref names, comma separated
        "%s",  #  15 | subject
        "%f",  #  16 | sanitazed subject
        "%GS",  # 17 | name of signer
        "%GK",  # 18 | key for signing
        "%G?",  # 19 | 'G' - good, "B" - bad, "U" - good untrusted, "N" - no
        "%b",  #  20 | message body
        COMMIT_FINISH_FORMAT
    ]
)
"""git log format for git process."""

SQLITE3_SCHEMA = """
DROP TABLE IF EXISTS commits;
CREATE TABLE commits (
    id                   INTEGER PRIMARY KEY,
    sha_full             TEXT    NOT NULL UNIQUE,
    sha_abbrev           TEXT    NOT NULL UNIQUE,
    author_id            INTEGER NOT NULL,
    mailmap_author_id    INTEGER NOT NULL,
    author_date          INTEGER NOT NULL,
    committer_id         INTEGER NOT NULL,
    mailmap_committer_id INTEGER NOT NULL,
    committer_date       INTEGER NOT NULL,
    subject              TEXT    NOT NULL,
    subject_sanitized    TEXT    NOT NULL,
    sign_id              INTEGER,
    sign_status          TEXT    NOT NULL,
    message              TEXT    NOT NULL,

    FOREIGN KEY(author_id)            REFERENCES developers(id),
    FOREIGN KEY(mailmap_author_id)    REFERENCES developers(id),
    FOREIGN KEY(committer_id)         REFERENCES developers(id),
    FOREIGN KEY(mailmap_committer_id) REFERENCES developers(id),
    FOREIGN KEY(sign_id)              REFERENCES signatures(id)
);

DROP TABLE IF EXISTS developers;
CREATE TABLE developers (
    id    INTEGER PRIMARY KEY,
    name  TEXT    NOT NULL,
    email TEXT    NOT NULL,

    UNIQUE(name, email)
);

DROP TABLE IF EXISTS signatures;
CREATE TABLE signatures (
    id   INTEGER PRIMARY KEY,
    name TEXT,
    key  TEXT    UNIQUE
);

DROP TABLE IF EXISTS log;
CREATE TABLE log (
    id     INTEGER PRIMARY KEY,
    child  INTEGER NOT NULL,
    parent INTEGER NOT NULL,

    FOREIGN KEY(child)  REFERENCES commits(id),
    FOREIGN KEY(parent) REFERENCES commits(id)
);

DROP TABLE IF EXISTS refspecs;
CREATE TABLE refspecs (
    name      TEXT    PRIMARY KEY,
    commit_id INTEGER NOT NULL,

    FOREIGN KEY(commit_id) REFERENCES commits(id)
);

DROP TABLE IF EXISTS changes;
CREATE TABLE changes (
    id           INTEGER PRIMARY KEY,
    commit_id    INTEGER NOT NULL,
    lines_add    INTEGER,
    lines_delete INTEGER,
    filename     TEXT NOT NULL,

    UNIQUE(commit_id, filename),
    FOREIGN KEY(commit_id) REFERENCES commits(id)
);
""".strip()
"""Schema of SQLite database."""


def commit_after(func):
    @functools.wraps(func)
    def decorator(self, *args, **kwargs):
        try:
            result = func(self, *args, **kwargs)
        except:
            logging.warning("COMMIT AFTER: Commit")
            self.connection.rollback()
            raise
        else:
            logging.debug("COMMIT AFTER: Commit")
            self.connection.commit()
            return result

    return decorator


class Progress(object):

    def __init__(self, stream, count):
        self.stream = stream
        self.size = count
        self.current = 0
        self.size_length = len(str(count))

    def update(self):
        self.current += 1
        self.stream.write("\r")
        self.stream.write(self.current_message)

    @property
    def current_message(self):
        return "{0} / {1} ({2}%)".format(
            self.current, self.size, 100 * float(self.current) / self.size)


class HideProgress(Progress):

    def update(self):
        pass


class Dumper(object):

    def __init__(self, own_options, progress):
        self.output = own_options.output
        self.progress = progress
        self.commit_counter = 0

    def dump(self, commits):
        for commit in commits:
            if commit is None:
                self.dump_none()
            else:
                self.commit_counter += 1
                self.dump_commit(commit)
                self.progress.update()

    def dump_none(self):
        pass

    def dump_commit(self, commit):
        pass


class JSONDumper(Dumper):

    def __init__(self, options, progress):
        super(JSONDumper, self).__init__(options, progress)

        self.line_ending = ",\n"
        if self.output == "-" or self.output is None:
            self.stream = sys.stdout
        else:
            self.stream = open(self.output, mode="wt")

    def dump(self, commits):
        print("[", file=self.stream)
        super(JSONDumper, self).dump(commits)
        print("]", file=self.stream)

    def dump_none(self):
        self.line_ending = "\n"

    def dump_commit(self, commit):
        json.dump(commit, self.stream, sort_keys=True, indent=4)
        self.stream.write(self.line_ending)


class XMLDumper(Dumper):

    def __init__(self, options, progress):
        super(XMLDumper, self).__init__(options, progress)

        if self.output == "-" or self.output is None:
            self.stream = sys.stdout
        else:
            self.stream = open(self.output, mode="wt")

    def dump(self, commits):
        print('<?xml version="1.0" encoding="UTF-8" standalone="no"?>',
              file=self.stream)
        print("<commits>", file=self.stream)
        super(XMLDumper, self).dump(commits)
        print("</commits>", file=self.stream)

    def dump_commit(self, commit):
        el_commit = etree.Element("commit")

        self.dump_commitsha(el_commit, commit["commitsha"])
        self.dump_parents(el_commit, commit["parents"])
        self.dump_developers(el_commit, commit["developers"])
        self.dump_refs(el_commit, commit["refspecs"])
        self.dump_changes(el_commit, commit["changes"])

        el_message = etree.SubElement(el_commit, "message")
        etree.SubElement(el_message, "subject").attrib.update(
            commit["message"]["subject"])
        el_message.attrib["body"] = commit["message"]["body"]
        el_message.attrib["raw"] = commit["message"]["raw"]

        print(etree.tostring(el_commit, encoding="utf-8"), file=self.stream)

    def dump_commitsha(self, root, commit):
        el_commitsha = etree.SubElement(root, "commitsha")

        for key in "full", "abbrev":
            el_commitsha.attrib[key] = commit[key]

    def dump_parents(self, root, parents):
        el_parents = etree.SubElement(root, "parents")

        for parent in parents:
            etree.SubElement(el_parents, "parent").attrib.update(parent)

    def dump_developers(self, root, devs):
        el_developers = etree.SubElement(root, "developers")
        self.dump_dev(el_developers, "author", devs["author"])
        self.dump_dev(el_developers, "committer", devs["committer"])
        self.dump_signer(el_developers, devs["signer"])

    def dump_dev(self, root, tagname, data):
        el_dev = etree.SubElement(root, tagname)
        for key, value in data.items():
            etree.SubElement(el_dev, key).attrib.update(
                dict((to_str(k), to_str(v)) for k, v in value.items()))

    def dump_signer(self, root, data):
        etree.SubElement(root, "signer").attrib.update(
            dict((k or "", v or "") for k, v in data.items()))

    def dump_refs(self, root, refs):
        el_ref = etree.SubElement(root, "refspecs")

        for ref in refs:
            etree.SubElement(el_ref, "refspec").text = ref

    def dump_changes(self, root, changes):
        el_changes = etree.SubElement(root, "changes")

        for change in changes:
            el_change = etree.SubElement(el_changes, "change")
            el_change.attrib["add"] = to_str(change["add"])
            el_change.attrib["delete"] = to_str(change["delete"])
            el_change.attrib["filename"] = change["filename"]


class SQLiteDumper(Dumper):

    DEFAULT_FILENAME = "dump.sqlite"
    DUMP_EVERY_COMMITS = 25

    def __init__(self, options, progress):
        super(SQLiteDumper, self).__init__(options, progress)

        self.connection = sqlite3.connect(self.output or self.DEFAULT_FILENAME)
        self.connection.row_factory = sqlite3.Row
        self.child_parents = {}
        self.commit_ids = {}
        self.cache_developer = {}
        self.cache_signer = {}

        self.create_db()

    def cursor(self):
        return self.connection.cursor()

    @commit_after
    def create_db(self):
        self.connection.executescript(SQLITE3_SCHEMA)
        self.connection.execute("VACUUM")

    def dump(self, commits):
        super(SQLiteDumper, self).dump(commits)

        self.connection.commit()
        self.dump_log()

        self.connection.execute("VACUUM")
        self.connection.commit()

    def dump_commit(self, commit):
        author_id = self.dump_developer(
            commit["developers"]["author"]["name"]["commit"],
            commit["developers"]["author"]["email"]["commit"])
        mailmap_author_id = self.dump_developer(
            commit["developers"]["author"]["name"]["mailmap"],
            commit["developers"]["author"]["email"]["mailmap"])
        committer_id = self.dump_developer(
            commit["developers"]["committer"]["name"]["commit"],
            commit["developers"]["committer"]["email"]["commit"])
        mailmap_committer_id = self.dump_developer(
            commit["developers"]["committer"]["name"]["mailmap"],
            commit["developers"]["committer"]["email"]["mailmap"])
        sign_id = self.dump_signature(commit["developers"]["signer"])

        cursor = self.connection.cursor()
        cursor.execute(
            (
                "INSERT INTO commits (sha_full, sha_abbrev, author_id, "
                "mailmap_author_id, author_date, committer_id, "
                "mailmap_committer_id, committer_date, subject, "
                "subject_sanitized, sign_id, sign_status, message) "
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"),
            (
                commit["commitsha"]["full"],
                commit["commitsha"]["abbrev"],
                author_id,
                mailmap_author_id,
                commit["developers"]["author"]["date"]["unix"],
                committer_id,
                mailmap_committer_id,
                commit["developers"]["committer"]["date"]["unix"],
                commit["message"]["subject"]["full"],
                commit["message"]["subject"]["sanitized"],
                sign_id,
                commit["developers"]["signer"]["status"],
                commit["message"]["body"]))
        commit_id = cursor.lastrowid

        self.commit_ids[commit["commitsha"]["abbrev"]] = commit_id
        self.child_parents[commit["commitsha"]["abbrev"]] = [
            cmt["abbrev"] for cmt in commit["parents"]]

        self.dump_refspecs(commit_id, commit["refspecs"])
        self.dump_changes(commit_id, commit["changes"])

        if self.commit_counter % self.DUMP_EVERY_COMMITS == 0:
            self.connection.commit()

    def dump_developer(self, name, email):
        cursor = self.connection.cursor()
        key = name, email

        cached = self.cache_developer.get(key)
        if cached is not None:
            return cached

        cursor.execute("INSERT INTO developers (name, email) VALUES (?, ?)",
                       key)
        self.cache_developer[key] = cursor.lastrowid

        return self.cache_developer[key]

    def dump_signature(self, data):
        if not data["key"]:
            return None

        cursor = self.connection.cursor()

        cached = self.cache_signer.get(data["key"])
        if cached is not None:
            cursor.execute(
                "UPDATE OR IGNORE signatures SET name = ? WHERE key = ?",
                (data["name"], data["key"]))

            return cached

        cursor.execute(
            "INSERT OR IGNORE INTO signatures (name, key) VALUES (?, ?)",
            (data["name"], data["key"]))
        self.cache_signer[data["key"]] = cursor.lastrowid

        return self.cache_signer[data["key"]]

    def dump_refspecs(self, commit_id, refs):
        cursor = self.connection.cursor()

        cursor.executemany(
            "INSERT INTO refspecs (name, commit_id) VALUES (?, ?)",
            [(ref, commit_id) for ref in refs])

    @commit_after
    def dump_log(self):
        cursor = self.connection.cursor()

        log_entries = []
        for child, parents in self.child_parents.items():
            for parent in parents:
                log_entries.append(
                    (self.commit_ids[child], self.commit_ids[parent]))

        if log_entries:
            cursor.executemany(
                "INSERT INTO log (child, parent) VALUES (?, ?)",
                log_entries)

    def dump_changes(self, commit_id, changes):
        cursor = self.connection.cursor()

        cursor.executemany(
            (
                "INSERT INTO changes (commit_id, lines_add, "
                "lines_delete, filename) VALUES (?, ?, ?, ?)"),
            [(commit_id, chng["add"], chng["delete"], chng["filename"])
             for chng in changes])


def main():
    own_options, git_options = get_options()

    logging.basicConfig(
        format="[%(levelname)-5s] %(message)s",
        level=logging.DEBUG if own_options.debug else logging.ERROR)

    progress = HideProgress
    if not own_options.debug and own_options.progress:
        progress = Progress

    if own_options.format == "json":
        dumper = JSONDumper
    elif own_options.format == "xml":
        dumper = XMLDumper
    else:
        dumper = SQLiteDumper

    dumper = dumper(own_options,
                    progress(sys.stderr, 1 + commit_count(git_options)))
    dumper.dump(fetch_commits(git_options))

    return os.EX_OK


def fetch_commits(options):
    lines = []
    iterator = git("log", "--pretty=tformat:" + COMMIT_FORMAT, "--numstat",
                   *options)

    for line in iterator:
        if line == COMMIT_START:
            logging.debug("FETCH COMMITs: Start detected")
            if lines:
                yield parse(lines)
                lines = []
        else:
            logging.debug("FETCH COMMITS: Add line to buffer")
            lines.append(line)

    logging.debug("FETCH COMMITS: Output exhausted")

    yield None

    if lines:
        yield parse(lines)


def commit_count(options):
    cmdline = ["git", "--pretty=format:"] + list(options)

    gitlog_proc = subprocess.Popen(
        ["git", "log", "--pretty=format:"] + list(options),
        shell=False, universal_newlines=True, stdout=subprocess.PIPE)
    wcl_proc = subprocess.Popen(
        ["wc", "-l"],
        shell=False, universal_newlines=True,
        stdin=gitlog_proc.stdout, stdout=subprocess.PIPE)
    gitlog_proc.stdout.close()

    stdout, _ = wcl_proc.communicate()

    return int(stdout.strip())


def parse(lines):
    finish_line = lines.index(COMMIT_FINISH)
    commit_data = parse_commit(lines[:finish_line])
    commit_data["changes"] = parse_numstat(lines[finish_line + 1:])

    logging.debug("PARSE: %s", commit_data)

    return commit_data


def parse_commit(lines):
    return {
        "commitsha": parse_commitsha(lines),
        "parents": parse_parents(lines),
        "developers": parse_developers(lines),
        "refspecs": parse_refs(lines),
        "message": parse_message(lines)}


def parse_commitsha(lines):
    return {"full": lines[0], "abbrev": lines[1]}


def parse_parents(lines):
    parents = []

    for full, abbrev in izip(lines[2].split(), lines[3].split()):
        parents.append({"full": full, "abbrev": abbrev})

    return parents


def parse_developers(lines):
    return {
        "author": parse_teammate(*lines[4:9]),
        "committer": parse_teammate(*lines[9:14]),
        "signer": parse_sign(*lines[17:20])}


def parse_refs(lines):
    refs = lines[14].split(",")
    refs = itertools.chain.from_iterable(ref.split("->") for ref in refs)
    refs = ifilter(None, (ref.strip() for ref in refs))
    refs = list(refs)

    return refs


def parse_message(lines):
    message = {
        "subject": {
            "full": lines[15],
            "sanitized": lines[16]},
        "body": "\n".join(lines[20:]).strip()}
    message["raw"] = message["subject"]["full"] + "\n" + message["body"]
    message["raw"] = message["raw"].strip()

    return message


def parse_numstat(lines):
    numstat = []

    for line in lines:
        if line:
            add, delete, filename = line.split("\t", 2)
            result = {
                "add": int(add) if add != "-" else None,
                "delete": int(delete) if delete != "-" else None,
                "filename": filename}
            numstat.append(result)

    return numstat


def parse_teammate(commit_name, mailmap_name, commit_mail, mailmap_mail,
                   timestamp):
    timestamp = int(timestamp)
    local_datetime = datetime.datetime.fromtimestamp(timestamp)
    utc_timestamp = datetime.datetime.utcfromtimestamp(timestamp)

    return {
        "name": {
            "commit": commit_name,
            "mailmap": mailmap_name},
        "email": {
            "commit": commit_mail,
            "mailmap": mailmap_mail},
        "date": {
            "unix": timestamp,
            "iso_local": local_datetime.isoformat(),
            "iso_utc": utc_timestamp.isoformat(),
            "local": local_datetime.strftime("%c")}}


def parse_sign(name, key, status):
    return {
        "name": name or None,
        "key": key or None,
        "status": status.upper()}


def filter_git_options(options):
    """Remove formatting options for git log."""

    options = ifilter(
        lambda opt: not opt.startswith(("--oneline", "--pretty", "--format")),
        options)

    return list(options)


def git(*options):
    """Iterator for given git command."""

    cmdline = ["git"] + list(options)
    logging.debug("GIT: Execute %r", subprocess.list2cmdline(cmdline))

    proc = subprocess.Popen(
        cmdline, shell=False, universal_newlines=True, stdout=subprocess.PIPE)

    # This is a workaround for PyPy. PyPy returns raw bytes here instead of
    # correct TextIOWrapper which manages encodings. So CPython spits unicode
    # and PyPy - strs here.
    stream = proc.stdout
    if not isinstance(stream, io.TextIOBase):
        reader = codecs.getreader("utf-8")
        stream = reader(stream, errors="replace")

    for line in (line.rstrip() for line in stream):
        logging.debug("GIT: Read %r", line)
        yield line

    stdout, _ = proc.communicate()
    if hasattr(stdout, "decode"):
        stdout = stdout.decode("utf-8")
    for line in (line.rstrip() for line in stdout.split()):
        logging.debug("GIT: Read %r", line)
        yield line


def get_options():
    parser = argparse.ArgumentParser(
        description="%(prog)s exports 'git log' data into choosen format.")

    parser.add_argument(
        "-d", "--debug",
        help="Run in debug mode",
        action="store_true",
        default=False)
    parser.add_argument(
        "-p", "--progress",
        help="Show simple progress indicator.",
        action="store_true",
        default=False)
    parser.add_argument(
        "-o", "--output",
        help="Filename to output",
        default=None)

    parser.add_argument(
        "format",
        help="Format to dump to",
        choices=("json", "sqlite", "xml"))
    parser.add_argument(
        "git_option",
        help="Options for 'git log'",
        nargs=argparse.ZERO_OR_MORE)

    parsed = parser.parse_args()
    git_options = filter_git_options(parsed.git_option)

    return parsed, git_options


if __name__ == "__main__":
    sys.exit(main())
