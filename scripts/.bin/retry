#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>
"""
This utility allows you to retry commands. E.g

    $ retry -a 3 -- rsync -av /var/backups/home.tar.gz remote:/var/dumps/

This will try 3 times to rsync backup before fail. Btw, there are 2
timeouts to set, lower and upper. retry will make timeout between them
in exponential fashion.
"""


import argparse
import math
import os
import subprocess
import sys
import time


FUNC = math.exp
"""Exponent for timeout."""


def main():
    """Main function."""

    opts = get_options()
    latest_exit_code = os.EX_SOFTWARE
    exit_codes = frozenset(opts.exit_codes)

    for it in range(opts.attempts):
        try:
            subprocess.check_call(opts.command, shell=False)
        except subprocess.CalledProcessError as exc:
            latest_exit_code = exc.returncode
        else:
            latest_exit_code = os.EX_OK

        if latest_exit_code in exit_codes:
            return latest_exit_code

        if it != opts.attempts - 1:
            timeout = how_long_to_sleep(
                it, opts.attempts, opts.min_timeout, opts.max_timeout)
            time.sleep(timeout)

    return latest_exit_code


def get_options():
    """This method build commandline parser and returns parsed namespace."""

    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-e", "--exit-codes",
        help="Exit codes that should be valid exit ones.",
        nargs="*",
        type=int,
        default=[os.EX_OK])
    parser.add_argument(
        "-a", "--attempts",
        help="How many attempts shall we perform?",
        type=int,
        default=1)
    parser.add_argument(
        "-l", "--min-timeout",
        help="Minimal timeout to wait between retries.",
        type=int,
        default=0)
    parser.add_argument(
        "-u", "--max-timeout",
        help="Maximal timeout to wait between retires.",
        type=int,
        default=0)
    parser.add_argument(
        "command",
        help="Command to execute.",
        nargs="+")

    return parser.parse_args()


def how_long_to_sleep(iteration, retries, minimum, maximum):
    """This function defines how long to sleep after iteration."""

    minimum, maximum = min(minimum, maximum), max(minimum, maximum)

    if minimum == maximum or retries == 1:
        return minimum

    y = float(maximum - minimum) / (FUNC(retries - 1) - FUNC(0))
    x = minimum - y * FUNC(0)

    return x + y * FUNC(iteration)


if __name__ == "__main__":
    sys.exit(main())
