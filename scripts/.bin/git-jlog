#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>


from __future__ import print_function

import itertools
import os
import subprocess
import sys

try:
    import simplejson as json
except ImportError:
    import json


if sys.version_info.major == 2:
    zip_longest = itertools.izip_longest
else:
    zip_longest = itertools.zip_longest


COMMIT_START = "\x01"
COMMIT_START_FORMAT = "%x01"
COMMIT_FINISH = "\x00"
COMMIT_FINISH_FORMAT = "%x00"
COMMIT_FORMAT = "%n".join(
    [
        COMMIT_START_FORMAT,
        "%H",  # full commit hash
        "%h",  # abbrev commit hash
        "%P",  # full parent hashes, space separated
        "%p",  # abbrev parent hashes, space separated
        "%aN",  # author name
        "%ae",  # set author email
        "%aE",  # author email, mapped by mailmap
        "%at",  # author date in timestamp
        "%cN",  # comitter name
        "%ce",  # comitter email
        "%cE",  # comitter email, mapped by mailmap
        "%ct",  # comitter date in timestamp
        "%D",  # ref names, comma separated
        "%s",  # subject
        "%f",  # sanitazed subject
        "%GS",  # name of signer
        "%GK",  # key for signing
        "%G?",  # 'G' for good, "B" for bad, "U" for good untrusted, "N" - no
        "%b",  # message body
        COMMIT_FINISH_FORMAT
    ]
)


class Commit(object):

    @staticmethod
    def parse_numstat(lines):
        for line in lines:
            if line:
                add, delete, filename = line.split()
                yield int(add), int(delete), filename

    def __init__(self):
        self.commitsha = {"full": "", "short": ""}
        self.author = {
            "name": "", "email": {"real": "", "commit": ""}, "timestamp": 0}
        self.committer = {
            "name": "", "email": {"real": "", "commit": ""}, "timestamp": 0}
        self.subject = {"real": "", "sanitized": ""}
        self.sign = {"name": "", "key": "", "status": ""}
        self.message = ""
        self.changes = []
        self.refs = []
        self.parents = []

    def parse(self, lines):
        final_line = lines.index(COMMIT_FINISH)

        self.commitsha["full"] = lines[0]
        self.commitsha["short"] = lines[1]

        for full, abbrev in zip_longest(lines[2].split(), lines[3].split()):
            self.parents.append({"full": full, "short": abbrev})

        self.author["name"] = lines[4]
        self.author["email"]["commit"] = lines[5]
        self.author["email"]["real"] = lines[6]
        self.author["date"] = int(lines[7])

        self.committer["name"] = lines[8]
        self.committer["email"]["commit"] = lines[9]
        self.committer["email"]["real"] = lines[10]
        self.committer["date"] = int(lines[11])

        self.refs = lines[12].split(", ")
        if self.refs[0] == "":
            self.refs = []

        self.subject["real"] = lines[13]
        self.subject["sanitized"] = lines[14]

        self.sign["name"] = lines[15] or None
        self.sign["key"] = lines[16] or None
        self.sign["status"] = lines[17]

        self.message = "\n".join([lines[13], ""] + lines[18:final_line])
        self.message = self.message.strip()

        for add, delete, fname in self.parse_numstat(lines[final_line + 1:]):
            self.changes.append(
                {"add": add, "delete": delete, "filename": fname})

    @property
    def json(self):
        return {
            "commitsha": self.commitsha,
            "author": self.author,
            "committer": self.committer,
            "subject": self.subject,
            "message": self.message,
            "sign": self.sign,
            "changes": self.changes,
            "refs": self.refs,
            "parents": self.parents}


def main():
    gitlog_options = filter_options(sys.argv[1:])

    commits = []
    for commit in fetch_commits(gitlog_options):
        commits.append(commit.json)

    print(json.dumps(commits, indent=4))

    return os.EX_OK


def fetch_commits(options):
    lines = []
    iterator = git("log", "--pretty=tformat:" + COMMIT_FORMAT, "--numstat",
                   *options)

    for line in iterator:
        if line == COMMIT_START:
            if lines:
                commit = Commit()
                commit.parse(lines)
                lines = []
                yield commit
        else:
            lines.append(line)


def filter_options(options):
    options = filter(
        lambda opt: not opt.startswith(("--oneline", "--pretty", "--format")),
        options)

    return list(options)


def git(*options):
    """Iterator for given git command."""

    proc = subprocess.Popen(
        ["git"] + list(options),
        shell=False, universal_newlines=True, stdout=subprocess.PIPE)

    for line in proc.stdout:
        yield line.rstrip()

    stdout, _ = proc.communicate()
    for line in stdout.split():
        yield stdout


if __name__ == "__main__":
    sys.exit(main())
