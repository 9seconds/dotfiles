#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>


from __future__ import absolute_import, print_function, unicode_literals

import codecs
import datetime
import io
import itertools
import json
import os
import platform
import subprocess
import sys


if platform.python_implementation() == "CPython":
    try:
        import ujson as json
    except ImportError:
        try:
            import simplejson as json
        except ImportError:
            pass

if sys.version_info.major == 2:
    ifilter = itertools.ifilter
    izip = itertools.izip
else:
    ifilter = filter
    izip = zip


COMMIT_START = "\x01"
COMMIT_START_FORMAT = "%x01"
COMMIT_FINISH = "\x00"
COMMIT_FINISH_FORMAT = "%x00"
COMMIT_FORMAT = "%n".join(
    [
        COMMIT_START_FORMAT,
        "%H",  #   0 | full commit hash
        "%h",  #   1 | 1abbrev commit hash
        "%P",  #   2 | full parent hashes, space separated
        "%p",  #   3 | abbrev parent hashes, space separated
        "%an",  #  4 | commit author name
        "%aN",  #  5 | mailmap author name
        "%ae",  #  6 | commit author email
        "%aE",  #  7 | mailmap author email
        "%at",  #  8 | author date in timestamp
        "%cn",  #  9 | commit committer name
        "%cN",  # 10 | mailmap comitter name
        "%ce",  # 11 | commit comitter email
        "%cE",  # 12 | mailmap comitter email
        "%ct",  # 13 | comitter date in timestamp
        "%D",  #  14 | ref names, comma separated
        "%s",  #  15 | subject
        "%f",  #  16 | sanitazed subject
        "%GS",  # 17 | name of signer
        "%GK",  # 18 | key for signing
        "%G?",  # 19 | 'G' - good, "B" - bad, "U" - good untrusted, "N" - no
        "%b",  #  20 | message body
        COMMIT_FINISH_FORMAT
    ]
)


def main():
    gitlog_options = filter_options(sys.argv[1:])
    json_ending = ",\n"

    print("[")
    for commit in fetch_commits(gitlog_options):
        if commit is None:
            json_ending = "\n"
            continue
        print(json.dumps(commit, indent=4), end=json_ending)
    print("]")

    return os.EX_OK


def fetch_commits(options):
    lines = []
    iterator = git("log", "--pretty=tformat:" + COMMIT_FORMAT, "--numstat",
                   *options)

    for line in iterator:
        if line == COMMIT_START:
            if lines:
                yield parse(lines)
                lines = []
        else:
            lines.append(line)

    yield None

    if lines:
        yield parse(lines)


def parse(lines):
    finish_line = lines.index(COMMIT_FINISH)

    commit_data = parse_commit(lines[:finish_line])
    commit_data["changes"] = parse_numstat(lines[finish_line + 1:])

    return commit_data


def parse_commit(lines):
    return {
        "commitsha": parse_commitsha(lines),
        "parents": parse_parents(lines),
        "people": parse_people(lines),
        "refs": parse_refs(lines),
        "message": parse_message(lines)}


def parse_commitsha(lines):
    return {"full": lines[0], "abbrev": lines[1]}


def parse_parents(lines):
    parents = []

    for full, abbrev in izip(lines[2].split(), lines[3].split()):
        parents.append({"full": full, "abbrev": abbrev})

    return parents


def parse_people(lines):
    return {
        "author": parse_teammate(*lines[4:9]),
        "committer": parse_teammate(*lines[9:14]),
        "signer": parse_sign(*lines[17:20])}


def parse_refs(lines):
    refs = lines[14].split(", ")
    refs = itertools.chain.from_iterable(ref.split(" -> ") for ref in refs)
    refs = ifilter(None, refs)
    refs = list(refs)

    return refs


def parse_message(lines):
    message = {
        "subject": {
            "full": lines[15],
            "sanitized": lines[16]
        },
        "body": "\n".join(lines[20:]).strip()}
    message["raw"] = message["subject"]["full"] + "\n" + message["body"]
    message["raw"] = message["raw"].strip()

    return message


def parse_numstat(lines):
    numstat = []

    for line in lines:
        if line:
            add, delete, filename = line.split("\t", 2)
            result = {
                "add": int(add) if add != "-" else None,
                "delete": int(delete) if delete != "-" else None,
                "filename": filename}
            numstat.append(result)

    return numstat


def parse_teammate(commit_name, mailmap_name, commit_mail, mailmap_mail,
                   timestamp):
    timestamp = int(timestamp)
    local_datetime = datetime.datetime.fromtimestamp(timestamp)
    utc_timestamp = datetime.datetime.utcfromtimestamp(timestamp)

    return {
        "name": {
            "commit": commit_name,
            "mailmap": mailmap_name},
        "email": {
            "commit": commit_mail,
            "mailmap": mailmap_name},
        "date": {
            "unix": timestamp,
            "iso_local": local_datetime.isoformat(),
            "iso_utc": utc_timestamp.isoformat(),
            "local": local_datetime.strftime("%c")}}


def parse_sign(name, key, status):
    return {
        "name": name or None,
        "key": key or None,
        "status": status.upper()}


def filter_options(options):
    """Remove formatting options for git log."""

    options = ifilter(
        lambda opt: not opt.startswith(("--oneline", "--pretty", "--format")),
        options)

    return list(options)


def git(*options):
    """Iterator for given git command."""

    proc = subprocess.Popen(
        ["git"] + list(options),
        shell=False, universal_newlines=True, stdout=subprocess.PIPE)

    # This is a workaround for PyPy. PyPy returns raw bytes here instead of
    # correct TextIOWrapper which manages encodings. So CPython spits unicode
    # and PyPy - strs here.
    stream = proc.stdout
    if not isinstance(stream, io.TextIOBase):
        reader = codecs.getreader("utf-8")
        stream = reader(stream, errors="replace")

    for line in stream:
        yield line.rstrip()

    stdout, _ = proc.communicate()
    if hasattr(stdout, "decode"):
        stdout = stdout.decode("utf-8")
    for line in stdout.split():
        yield line


if __name__ == "__main__":
    sys.exit(main())
